---
layout: post
title: LeetCode 39
category: 技术
tags: LeetCode Medium unsolved
keywords: LeetCode
description: 2019 每天一道题 #39
---

#### 39. [Combination Sum](https://leetcode.com/problems/combination-sum/)
---
Given a **set** of candidate numbers (`candidates`) (**without duplicates**) and a target number (`target`), find all unique combinations in candidates where the `candidate` numbers sums to `target`.

The **same** repeated number may be chosen from `candidates` unlimited number of times.

**Note:**

- All numbers (including `target`) will be **positive** integers.
- The solution set must not contain duplicate combinations.

**Example 1:**
```
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
```
**Example 2:**
```
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

#### Thoughts
---
Firstly, calculate every `target % in[i]`, add `target / in[i]` times `in[i]` to the `tmpList` if it equals to `0`, otherwise mod subtract `in[i]` and do it again.

**First try:**
```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates);
        // empty set or target is too small
        if (candidates.length == 0 || candidates[0] > target)
            return res;
        List<Integer> in = new ArrayList<>();
        for (int i : candidates) {
            in.add(i);
        }

        for (int i = 0; i < in.size() && in.get(i) <= target; i++) {
            List<Integer> ok = new ArrayList<>();
            int times = target / in.get(i);
            int tmp = target - in.get(i);
            while (tmp >= 0 && times > 0) {
                int t = target / in.get(i);
                if (tmp == 0) {
                    // how many in.get(i) should be put in
                    while (t > 0) {
                        ok.add(in.get(i));
                        t--;
                    }
                }else if (in.contains(tmp)) {
                    while (t >= times) {
                        ok.add(in.get(i));
                        t--;
                    }
                    ok.add(tmp);
                   
                }
                // sort and remove duplication
                Collections.sort(ok);
                if (!res.contains(ok) && ok.size() > 0)
                    res.add(ok);
                ok = new ArrayList<>();

                tmp -= (in.get(i));
                times--;
            }
        }
        return res;
    }
}
```

**Result 1:**
```
input [1,2,3,6,7] 6
Output [[1,1,1,3],[1,1,1,1,2],[1,1,1,1,1,1],[2,2,2],[3,3],[6]]
Expected [[1,1,1,1,1,1],[1,1,1,1,2],[1,1,1,3],[1,1,2,2],[1,2,3],[2,2,2],[3,3],[6]]
```
We can see from the result that my code had problem with `1,1,2,2` or `1,2,3`, Cause it did not take multi dulicate number into account, need to spend more time on this later.

**Second try:**


**Result 2:**

