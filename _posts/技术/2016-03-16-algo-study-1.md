---
layout: post
title: 经典算法学习：排序问题
category: 技术
tags: 算法
keywords: 
description: 
---

### 排序算法学习


一直都没有系统地学习过算法、数据结构方面的知识，当然也知道这不是长久之计，所以开始把算法的学习加入计划中。最近看了MoreWindows的博客[白话经典算法系列][1]，看别人的代码倒是能理解，但要自己写又写不出来了，所以还是要做笔记才行。

|--------+----------+------|
|排序方法|时间复杂度|稳定性|
|:------:|:--------:|:----:|
|冒泡排序|O(n^2)     |稳定|
|直插排序|O(n^2)     |稳定|
|希尔排序|O(n^1.3)   |不稳定|
|归并排序|$$O(nlog_2n)$$|稳定|
|快速排序|$$O(nlog_2n)$$|不稳定|
|========+===========+=======|

|-----------------+------------+-----------------+----------------|
| Default aligned |Left aligned| Center aligned  | Right aligned  |
|-----------------|:-----------|:---------------:|---------------:|
| First body part |Second cell | Third cell      | fourth cell    |
| Second line     |foo         | **strong**      | baz            |
| Third line      |quux        | baz             | bar            |
|-----------------+------------+-----------------+----------------|
| Second body     |            |                 |                |
| 2 line          |            |                 |                |
|=================+============+=================+================|
| Footer row      |            |                 |                |
|-----------------+------------+-----------------+----------------|

- 冒泡排序
- 直插排序
- 希尔排序
- 归并排序
- 快速排序

### 冒泡排序

时间复杂度为O(N^2)，内层循环每次结束的时候会使得“最大”的那个数排到最后。下面的代码是[冒泡排序的三种实现][2]中的第三种，比一般的实现优化了不少。

```//冒泡排序3  
void BubbleSort3(int a[], int n)  
{  
    int j, k;  
    int flag;  
      
    flag = n;  //已完成排序的（从右到左）
    while (flag > 0)  
    {  
        k = flag;  
        flag = 0;  
        for (j = 1; j < k; j++)  
            if (a[j - 1] > a[j])  
            {  
                Swap(a[j - 1], a[j]);  
                flag = j;  
            }  
    }  
}  
```

### 直插排序

有地儿类似冒泡排序，只是每次比较的时候，都是a[i+1]与a[0]到a[i]比较个遍，找到合适的位置插入。时间复杂度同样为O(N^2)

```//直插排序2
void Insertsort2(int a[], int n)  
{  
    int i, j;  
    for (i = 1; i < n; i++)  
        if (a[i] < a[i - 1])  
        {  
            int temp = a[i];  
            for (j = i - 1; j >= 0 && a[j] > temp; j--)  //找到合适的位置
                a[j + 1] = a[j];  
            a[j + 1] = temp;  
        }  
}  
```
[直插排序的三种实现][3]中的第三种实现方法，就真的很像冒泡。代码虽然简洁了，但swap方法多调用了很多次（具体多少次我也不知道。。）确实代码的整洁跟效率之间，还需要多思考。

```//直插排序3
void Insertsort3(int a[], int n)  
{  
    int i, j;  
    for (i = 1; i < n; i++)  
        for (j = i - 1; j >= 0 && a[j] > a[j + 1]; j--)  
            Swap(a[j], a[j + 1]);  
}  
```

### 希尔排序

与直插排序相比也有点类似，将原始数据分组再做直插排序，然后缩小分组的组距，直到组距为1.代码来自[希尔排序][4]

```
/*
 * 希尔排序
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     n -- 数组的长度
 */
void shell_sort1(int a[], int n)
{
    int i,j,gap;

    // gap为步长，每次减为原来的一半。
    for (gap = n / 2; gap > 0; gap /= 2)
    {
        // 共gap个组，对每一组都执行直接插入排序
        for (i = 0 ;i < gap; i++)
        {
            for (j = i + gap; j < n; j += gap) 
            {
                // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。
                if (a[j] < a[j - gap])
                {
                    int tmp = a[j];
                    int k = j - gap;
                    while (k >= 0 && a[k] > tmp)
                    {
                        a[k + gap] = a[k];
                        k -= gap;
                    }
                    a[k + gap] = tmp;
                }
            }
        }

    }
}
```


[1]:http://blog.csdn.net/morewindows/article/details/17488865 "白话经典算法"
[2]:http://blog.csdn.net/morewindows/article/details/6657829 "冒泡排序的三种实现"
[3]:http://blog.csdn.net/morewindows/article/details/6665714 "直插排序的三种实现"
[4]:http://www.cnblogs.com/skywang12345/p/3597597.html "希尔排序"

【3】[3]:[图形化的算法演示网站](http://zh.visualgo.net/)
