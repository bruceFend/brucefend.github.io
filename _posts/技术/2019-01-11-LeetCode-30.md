---
layout: post
title: LeetCode 30
category: 技术
tags: LeetCode Hard
keywords: LeetCode
description: 2019 每天一道题 #30
---

#### 30. [Substring with Concatenation of All Words](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)
---
You are given a string, `s`, and a list of words, `words`, that are all of the **same length**. Find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` **exactly once** and without any intervening characters.

**Example 1:**
```
Input:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.
```
**Example 2:**
```
Input:
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
Output: []
```
#### Thoughts
---
I was quite disappointed when I found myself misunderstood about the question, cause I thought this shouldn't be that "hard" at the beginning. After some try, my idea was to remove every `word` once being found in the `substring` of `s`, return the current position `i` if every `word` was found. And the length of `substring` equals to `words.length * eachWordLen`.

**First try:**
```Java
class Solution {
    // #30
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<>();
        // words is empty,return empty list;
        if (words.length == 0 || (s.length() == 0 && words[0].length() > 0))
            return res;

        // words = [""], return every single number
        int eachLen = words[0].length();
        if (eachLen == 0) {
            for (int i = 0; i <= s.length(); i++)
                res.add(i);
            return res;
        }

        HashSet<Integer> t = new HashSet<>();
        for (int i = 0; i + eachLen * words.length  <= s.length(); i++) {
            StringBuilder tmp = new StringBuilder(s.substring(i , i+ eachLen * words.length));
            for (int j = 0; j < words.length; j++) {
                int ind = tmp.toString().indexOf(words[j]);
                if (ind > -1) {
                    // remove found words
                    // todo: may remove the wrong substring when tmp contains words more than once !
                    tmp = tmp.replace(ind, ind + eachLen, "");
                } else {
                    break;
                }
                if (j == words.length - 1)
                    t.add(ind + i);
            }
        }
        return new ArrayList<>(t);
    }
}
```

**Result 1:**
```
Input
"ababaab"
["ab","ba","ba"]
Output []
Expected [1]
```
This is because when `i = 1` and `words = ab`, `tmp = babaab`, my code remove the first *ab* when I was trying to remove the second *ab* from `babaab`.

**Second try:**


**Result 2:**

